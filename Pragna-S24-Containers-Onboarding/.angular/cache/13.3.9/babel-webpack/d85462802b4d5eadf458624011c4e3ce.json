{"ast":null,"code":"import _asyncToGenerator from \"/Users/pragna/Tech4Good/Web-Dev/containers-onboarding/longtermgoals-setup-uosnjl/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { from, of, combineLatest, merge, BehaviorSubject } from 'rxjs';\nimport { switchMap, mergeMap, skip, delay, tap, scan, publishReplay, map, take } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/store\";\nimport * as i2 from \"./mock-db.service\";\nexport class FirebaseService {\n  constructor(store, mockDBService) {\n    var _this = this;\n\n    this.store = store;\n    this.mockDBService = mockDBService; // Constant for simulating delay (e.g. to see loading icon in action)\n\n    this.LATENCY_SIMULATION_DELAY = 2000;\n\n    this.reducer = (entities, changes) => {\n      for (const c of changes) {\n        switch (c.type) {\n          case 'added':\n            entities[c.result.__id] = c.result;\n            break;\n\n          case 'modified':\n            entities[c.result.__id] = Object.assign({}, entities[c.result.__id], c.result);\n            break;\n\n          case 'removed':\n            delete entities[c.result.__id];\n            break;\n        }\n      }\n\n      return entities;\n    };\n\n    this.createId = () => {\n      var S4 = function () {\n        return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n      };\n\n      return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();\n    };\n\n    this.afUser = () => {\n      return this.mockAfUser.asObservable();\n    };\n\n    this.loadCurrentUserData = afUser => {\n      for (const collection in this.mockDBChanges) {\n        if (this.mockDBChanges.hasOwnProperty(collection)) {\n          this.mockDBChanges[collection].next(this.mockDBService.getCurrentUserDBStateChanges(collection, afUser.uid));\n        }\n      }\n    };\n\n    this.login = (providerId, scope) => {\n      const afUser = this.mockDBService.currentUser();\n      this.mockAfUser.next(afUser);\n      this.loadCurrentUserData(afUser);\n      return of({\n        credential: {\n          providerId,\n          accessToken: 'faketoken'\n        },\n        user: afUser\n      }).pipe(mergeMap(results => {\n        return this.queryObjOnce('users', results.user.uid).pipe(map(dbUser => Object.assign({}, results, {\n          dbUser\n        })));\n      }));\n    };\n\n    this.loginLink = error => {\n      return;\n    };\n\n    this.queryObjValueChanges = (collection, id) => {\n      return this.mockDB[collection].pipe(map(entities => entities[id]));\n    };\n\n    this.queryListStateChanges = (collection, queryParams, queryOptions) => {\n      if (queryParams.length === 0) {\n        return this.queryListValueChanges(collection, queryParams, queryOptions).pipe(take(1), mergeMap(entities => {\n          return merge(of(entities.map(e => ({\n            type: 'added',\n            result: e\n          }))), this.mockDBChanges[collection].asObservable().pipe(skip(1)));\n        }));\n      } else {\n        return this.queryListValueChanges(collection, queryParams, queryOptions).pipe(take(1), mergeMap(entities => {\n          return merge(of(entities.map(e => ({\n            type: 'added',\n            result: e\n          }))), this.mockDBChanges[collection].asObservable().pipe(skip(1), map(changes => {\n            // Filter out changes relevant for our query\n            return changes.filter(change => {\n              // We need to check if the query filters match the entity being changed. For a 'modified'\n              // change, we need to check a match on either the original or updated entity\n              const toCheck = [change.result];\n\n              if (change.type === 'modified') {\n                toCheck.push(change.original);\n              } // Looks for the first failed filter. If there exists any,\n              // return false (filter it out)\n\n\n              return !queryParams.find(f => {\n                const [key, rel, val] = f; // currently, we handle '==' and 'in'.\n\n                switch (rel) {\n                  case '==':\n                    return !toCheck.find(e => val === e[key]);\n\n                  case 'in':\n                    return !toCheck.find(e => val.find(v => e[key] === v));\n\n                  default:\n                    return false;\n                }\n              });\n            });\n          })));\n        }));\n      }\n    };\n\n    this.queryListValueChanges = (collection, queryParams, queryOptions) => {\n      return this.mockDB[collection].pipe(map(entities => {\n        let filteredEntities = []; // If the first entry is filtering by '__id', we process that first\n        // since it is more efficient. Otherwise, start with the full list.\n\n        if (queryParams && queryParams[0] && queryParams[0][0] === '__id') {\n          switch (queryParams[0][1]) {\n            case '==':\n              {\n                filteredEntities.push(entities[queryParams[0][2]]);\n                break;\n              }\n\n            case 'in':\n              {\n                // We are using loop syntax instead of map so that we can exit\n                // early if a desired entity has not been loaded into store.\n                const uniqueIds = queryParams[0][2].filter((x, i, a) => a.indexOf(x) === i);\n\n                for (const id of uniqueIds) {\n                  if (!entities[id]) {\n                    return undefined;\n                  } else {\n                    filteredEntities.push(entities[id]);\n                  }\n                }\n\n                break;\n              }\n          }\n        } else {\n          filteredEntities = Object.keys(entities).map(id => entities[id]);\n        }\n\n        if (queryParams) {\n          // Then process the remaining filters.\n          filteredEntities = filteredEntities.filter(e => {\n            // Looks for the first failed filter. If there exists any,\n            // return false (filter it out)\n            return !queryParams.find(f => {\n              const [key, rel, val] = f; // already processed '__id' so always passes this filter\n\n              if (key === '__id') {\n                return false;\n              } // currently, we handle '==' and 'in'.\n\n\n              switch (rel) {\n                case '==':\n                  return !(val === e[key]);\n\n                case 'in':\n                  return !val.find(v => e[key] === v);\n\n                default:\n                  return false;\n              }\n            });\n          });\n        }\n\n        return filteredEntities;\n      }));\n    };\n\n    this.addEntity = (collection, entity) => {\n      this.mockDBChanges[collection].next([{\n        type: 'added',\n        result: entity\n      }]);\n      return of(undefined).pipe(delay(this.LATENCY_SIMULATION_DELAY));\n    };\n\n    this.updateEntity = (collection, id, changes) => {\n      return this.mockDB[collection].pipe(map(entities => {\n        const original = entities[id];\n        return [original, Object.assign({}, original, changes)];\n      }), take(1), tap(([original, entity]) => {\n        this.mockDBChanges[collection].next([{\n          type: 'modified',\n          result: entity,\n          original\n        }]);\n      }), map(entity => undefined), delay(this.LATENCY_SIMULATION_DELAY));\n    };\n\n    this.upsertEntity = (collection, entity) => {\n      return from(_asyncToGenerator(function* () {\n        const dbEntity = yield _this.queryObjOnce(collection, entity.__id).toPromise();\n\n        if (dbEntity) {\n          return {\n            type: 'update',\n            value: yield _this.updateEntity(collection, entity.__id, entity)\n          };\n        } else {\n          return {\n            type: 'add',\n            value: yield _this.addEntity(collection, entity)\n          };\n        }\n      })());\n    };\n\n    this.removeEntity = (collection, id) => {\n      return this.mockDB[collection].pipe(map(entities => entities[id]), take(1), tap(entity => {\n        this.mockDBChanges[collection].next([{\n          type: 'removed',\n          result: entity\n        }]);\n      }), map(entity => undefined), delay(this.LATENCY_SIMULATION_DELAY));\n    };\n\n    this.mockAfUser = new BehaviorSubject(undefined); // Essentially mocking stateChanges in Firebase\n\n    this.mockDBChanges = {\n      // Entity Models\n      weekGoals: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('weekGoals')),\n      weeks: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('weeks')),\n      calendarEvents: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('calendarEvents')),\n      users: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('users')),\n      quarters: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('quarters')),\n      quarterGoals: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('quarterGoals')),\n      longTermGoals: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('longTermGoals'))\n    }; // Create the mockDB (valueChanges) by scanning the stateChanges\n\n    this.mockDB = {};\n\n    for (const collection in this.mockDBChanges) {\n      if (this.mockDBChanges.hasOwnProperty(collection)) {\n        const valChangeObs$ = this.mockDBChanges[collection].pipe(scan(this.reducer, {}), publishReplay(1)); // Connect now rather than waiting for first subscription otherwise could miss initial values\n\n        valChangeObs$.connect();\n        this.mockDB[collection] = valChangeObs$;\n      }\n    } // Auto login if applicable\n\n\n    const afUser = this.mockDBService.currentUser();\n    this.mockAfUser.next(afUser);\n    this.loadCurrentUserData(afUser);\n  }\n\n  queryObjOnce(collection, id, childrenFn) {\n    return this.queryObjValueChanges(collection, id).pipe(take(1), switchMap(e => {\n      if (!e || !childrenFn) {\n        return of(e);\n      } else {\n        const children = childrenFn(e); // transform the hash of observables into an array of observable hashes\n\n        const obsArray = Object.keys(children).map(objKey => {\n          const obs = children[objKey];\n          return obs.pipe(map(entity => {\n            const obj = {};\n            obj[objKey] = entity;\n            return obj;\n          }));\n        });\n        return obsArray.length === 0 ? of(e) : combineLatest(obsArray).pipe(map(array => {\n          return Object.assign({}, e, ...array);\n        }));\n      }\n    }));\n  }\n\n  queryListOnce(collection, queryParams, queryOptions, childrenFn) {\n    return this.queryListValueChanges(collection, queryParams, queryOptions).pipe(take(1), switchMap(entities => {\n      if (!entities || !childrenFn || entities.length === 0) {\n        return of(entities);\n      } else {\n        return combineLatest(entities.map(e => {\n          // If there are children, then we need to transform the hash of observables into an observable with the data object\n          const children = childrenFn(e);\n          const obsArray = Object.keys(children).map(objKey => {\n            const obs = children[objKey];\n            return obs.pipe(map(entity => {\n              const obj = {};\n              obj[objKey] = entity;\n              return obj;\n            }));\n          });\n          return obsArray.length === 0 ? of(e) : combineLatest(obsArray).pipe(map(array => {\n            return Object.assign({}, e, ...array);\n          }));\n        }));\n      }\n    }));\n  }\n\n}\n\nFirebaseService.ɵfac = function FirebaseService_Factory(t) {\n  return new (t || FirebaseService)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.MockDBService));\n};\n\nFirebaseService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FirebaseService,\n  factory: FirebaseService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/Users/pragna/Tech4Good/Web-Dev/containers-onboarding/longtermgoals-setup-uosnjl/src/app/core/firebase/firebase.service.ts"],"names":["from","of","combineLatest","merge","BehaviorSubject","switchMap","mergeMap","skip","delay","tap","scan","publishReplay","map","take","i0","i1","i2","FirebaseService","constructor","store","mockDBService","LATENCY_SIMULATION_DELAY","reducer","entities","changes","c","type","result","__id","Object","assign","createId","S4","Math","random","toString","substring","afUser","mockAfUser","asObservable","loadCurrentUserData","collection","mockDBChanges","hasOwnProperty","next","getCurrentUserDBStateChanges","uid","login","providerId","scope","currentUser","credential","accessToken","user","pipe","results","queryObjOnce","dbUser","loginLink","error","queryObjValueChanges","id","mockDB","queryListStateChanges","queryParams","queryOptions","length","queryListValueChanges","e","filter","change","toCheck","push","original","find","f","key","rel","val","v","filteredEntities","uniqueIds","x","i","a","indexOf","undefined","keys","addEntity","entity","updateEntity","upsertEntity","dbEntity","toPromise","value","removeEntity","weekGoals","getInitialDBStateChanges","weeks","calendarEvents","users","quarters","quarterGoals","longTermGoals","valChangeObs$","connect","childrenFn","children","obsArray","objKey","obs","obj","array","queryListOnce","ɵfac","FirebaseService_Factory","t","ɵɵinject","Store","MockDBService","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { from, of, combineLatest, merge, BehaviorSubject } from 'rxjs';\nimport { switchMap, mergeMap, skip, delay, tap, scan, publishReplay, map, take } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/store\";\nimport * as i2 from \"./mock-db.service\";\nexport class FirebaseService {\n    constructor(store, mockDBService) {\n        this.store = store;\n        this.mockDBService = mockDBService;\n        // Constant for simulating delay (e.g. to see loading icon in action)\n        this.LATENCY_SIMULATION_DELAY = 2000;\n        this.reducer = (entities, changes) => {\n            for (const c of changes) {\n                switch (c.type) {\n                    case 'added':\n                        entities[c.result.__id] = c.result;\n                        break;\n                    case 'modified':\n                        entities[c.result.__id] = Object.assign({}, entities[c.result.__id], c.result);\n                        break;\n                    case 'removed':\n                        delete entities[c.result.__id];\n                        break;\n                }\n            }\n            return entities;\n        };\n        this.createId = () => {\n            var S4 = function () {\n                return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n            };\n            return (S4() +\n                S4() +\n                '-' +\n                S4() +\n                '-' +\n                S4() +\n                '-' +\n                S4() +\n                '-' +\n                S4() +\n                S4() +\n                S4());\n        };\n        this.afUser = () => {\n            return this.mockAfUser.asObservable();\n        };\n        this.loadCurrentUserData = (afUser) => {\n            for (const collection in this.mockDBChanges) {\n                if (this.mockDBChanges.hasOwnProperty(collection)) {\n                    this.mockDBChanges[collection].next(this.mockDBService.getCurrentUserDBStateChanges(collection, afUser.uid));\n                }\n            }\n        };\n        this.login = (providerId, scope) => {\n            const afUser = this.mockDBService.currentUser();\n            this.mockAfUser.next(afUser);\n            this.loadCurrentUserData(afUser);\n            return of({\n                credential: { providerId, accessToken: 'faketoken' },\n                user: afUser,\n            }).pipe(mergeMap((results) => {\n                return this.queryObjOnce('users', results.user.uid).pipe(map((dbUser) => Object.assign({}, results, { dbUser })));\n            }));\n        };\n        this.loginLink = (error) => {\n            return;\n        };\n        this.queryObjValueChanges = (collection, id) => {\n            return this.mockDB[collection].pipe(map((entities) => entities[id]));\n        };\n        this.queryListStateChanges = (collection, queryParams, queryOptions) => {\n            if (queryParams.length === 0) {\n                return this.queryListValueChanges(collection, queryParams, queryOptions).pipe(take(1), mergeMap((entities) => {\n                    return merge(of(entities.map((e) => ({ type: 'added', result: e }))), this.mockDBChanges[collection].asObservable().pipe(skip(1)));\n                }));\n            }\n            else {\n                return this.queryListValueChanges(collection, queryParams, queryOptions).pipe(take(1), mergeMap((entities) => {\n                    return merge(of(entities.map((e) => ({ type: 'added', result: e }))), this.mockDBChanges[collection].asObservable().pipe(skip(1), map((changes) => {\n                        // Filter out changes relevant for our query\n                        return changes.filter((change) => {\n                            // We need to check if the query filters match the entity being changed. For a 'modified'\n                            // change, we need to check a match on either the original or updated entity\n                            const toCheck = [change.result];\n                            if (change.type === 'modified') {\n                                toCheck.push(change.original);\n                            }\n                            // Looks for the first failed filter. If there exists any,\n                            // return false (filter it out)\n                            return !queryParams.find((f) => {\n                                const [key, rel, val] = f;\n                                // currently, we handle '==' and 'in'.\n                                switch (rel) {\n                                    case '==':\n                                        return !toCheck.find((e) => val === e[key]);\n                                    case 'in':\n                                        return !toCheck.find((e) => val.find((v) => e[key] === v));\n                                    default:\n                                        return false;\n                                }\n                            });\n                        });\n                    })));\n                }));\n            }\n        };\n        this.queryListValueChanges = (collection, queryParams, queryOptions) => {\n            return this.mockDB[collection].pipe(map((entities) => {\n                let filteredEntities = [];\n                // If the first entry is filtering by '__id', we process that first\n                // since it is more efficient. Otherwise, start with the full list.\n                if (queryParams && queryParams[0] && queryParams[0][0] === '__id') {\n                    switch (queryParams[0][1]) {\n                        case '==': {\n                            filteredEntities.push(entities[queryParams[0][2]]);\n                            break;\n                        }\n                        case 'in': {\n                            // We are using loop syntax instead of map so that we can exit\n                            // early if a desired entity has not been loaded into store.\n                            const uniqueIds = queryParams[0][2].filter((x, i, a) => a.indexOf(x) === i);\n                            for (const id of uniqueIds) {\n                                if (!entities[id]) {\n                                    return undefined;\n                                }\n                                else {\n                                    filteredEntities.push(entities[id]);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n                else {\n                    filteredEntities = Object.keys(entities).map((id) => entities[id]);\n                }\n                if (queryParams) {\n                    // Then process the remaining filters.\n                    filteredEntities = filteredEntities.filter((e) => {\n                        // Looks for the first failed filter. If there exists any,\n                        // return false (filter it out)\n                        return !queryParams.find((f) => {\n                            const [key, rel, val] = f;\n                            // already processed '__id' so always passes this filter\n                            if (key === '__id') {\n                                return false;\n                            }\n                            // currently, we handle '==' and 'in'.\n                            switch (rel) {\n                                case '==':\n                                    return !(val === e[key]);\n                                case 'in':\n                                    return !val.find((v) => e[key] === v);\n                                default:\n                                    return false;\n                            }\n                        });\n                    });\n                }\n                return filteredEntities;\n            }));\n        };\n        this.addEntity = (collection, entity) => {\n            this.mockDBChanges[collection].next([\n                {\n                    type: 'added',\n                    result: entity,\n                },\n            ]);\n            return of(undefined).pipe(delay(this.LATENCY_SIMULATION_DELAY));\n        };\n        this.updateEntity = (collection, id, changes) => {\n            return this.mockDB[collection].pipe(map((entities) => {\n                const original = entities[id];\n                return [original, Object.assign({}, original, changes)];\n            }), take(1), tap(([original, entity]) => {\n                this.mockDBChanges[collection].next([\n                    {\n                        type: 'modified',\n                        result: entity,\n                        original,\n                    },\n                ]);\n            }), map((entity) => undefined), delay(this.LATENCY_SIMULATION_DELAY));\n        };\n        this.upsertEntity = (collection, entity) => {\n            return from((async () => {\n                const dbEntity = await this.queryObjOnce(collection, entity.__id).toPromise();\n                if (dbEntity) {\n                    return {\n                        type: 'update',\n                        value: await this.updateEntity(collection, entity.__id, entity),\n                    };\n                }\n                else {\n                    return {\n                        type: 'add',\n                        value: await this.addEntity(collection, entity),\n                    };\n                }\n            })());\n        };\n        this.removeEntity = (collection, id) => {\n            return this.mockDB[collection].pipe(map((entities) => entities[id]), take(1), tap((entity) => {\n                this.mockDBChanges[collection].next([\n                    {\n                        type: 'removed',\n                        result: entity,\n                    },\n                ]);\n            }), map((entity) => undefined), delay(this.LATENCY_SIMULATION_DELAY));\n        };\n        this.mockAfUser = new BehaviorSubject(undefined);\n        // Essentially mocking stateChanges in Firebase\n        this.mockDBChanges = {\n            // Entity Models\n            weekGoals: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('weekGoals')),\n            weeks: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('weeks')),\n            calendarEvents: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('calendarEvents')),\n            users: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('users')),\n            quarters: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('quarters')),\n            quarterGoals: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('quarterGoals')),\n            longTermGoals: new BehaviorSubject(this.mockDBService.getInitialDBStateChanges('longTermGoals')),\n        };\n        // Create the mockDB (valueChanges) by scanning the stateChanges\n        this.mockDB = {};\n        for (const collection in this.mockDBChanges) {\n            if (this.mockDBChanges.hasOwnProperty(collection)) {\n                const valChangeObs$ = this.mockDBChanges[collection].pipe(scan(this.reducer, {}), publishReplay(1));\n                // Connect now rather than waiting for first subscription otherwise could miss initial values\n                valChangeObs$.connect();\n                this.mockDB[collection] = valChangeObs$;\n            }\n        }\n        // Auto login if applicable\n        const afUser = this.mockDBService.currentUser();\n        this.mockAfUser.next(afUser);\n        this.loadCurrentUserData(afUser);\n    }\n    queryObjOnce(collection, id, childrenFn) {\n        return this.queryObjValueChanges(collection, id).pipe(take(1), switchMap((e) => {\n            if (!e || !childrenFn) {\n                return of(e);\n            }\n            else {\n                const children = childrenFn(e);\n                // transform the hash of observables into an array of observable hashes\n                const obsArray = Object.keys(children).map((objKey) => {\n                    const obs = children[objKey];\n                    return obs.pipe(map((entity) => {\n                        const obj = {};\n                        obj[objKey] = entity;\n                        return obj;\n                    }));\n                });\n                return obsArray.length === 0\n                    ? of(e)\n                    : combineLatest(obsArray).pipe(map((array) => {\n                        return Object.assign({}, e, ...array);\n                    }));\n            }\n        }));\n    }\n    queryListOnce(collection, queryParams, queryOptions, childrenFn) {\n        return this.queryListValueChanges(collection, queryParams, queryOptions).pipe(take(1), switchMap((entities) => {\n            if (!entities || !childrenFn || entities.length === 0) {\n                return of(entities);\n            }\n            else {\n                return combineLatest(entities.map((e) => {\n                    // If there are children, then we need to transform the hash of observables into an observable with the data object\n                    const children = childrenFn(e);\n                    const obsArray = Object.keys(children).map((objKey) => {\n                        const obs = children[objKey];\n                        return obs.pipe(map((entity) => {\n                            const obj = {};\n                            obj[objKey] = entity;\n                            return obj;\n                        }));\n                    });\n                    return obsArray.length === 0\n                        ? of(e)\n                        : combineLatest(obsArray).pipe(map((array) => {\n                            return Object.assign({}, e, ...array);\n                        }));\n                }));\n            }\n        }));\n    }\n}\nFirebaseService.ɵfac = function FirebaseService_Factory(t) { return new (t || FirebaseService)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.MockDBService)); };\nFirebaseService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: FirebaseService, factory: FirebaseService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}